## java基础
### Iterator方法说明
* 在创建迭代器之后，除非通过迭代器自身的remove 或add 方法从结构上对列表进行修改，否则`在任何时间以任何方式对列表进行修改`，迭代器都会抛出ConcurrentModificationException。
* 如果要通过迭代器删除一个元素，首先要通过next() 方法获取该元素。[注:previous()方法也可以]
* 迭代器的remove操作删除的是最近一次由next操作获取的元素，而不是当前游标所指向的元素。
* 每执行一次next，Iterator迭代器的游标都会指向下一个元素，而不是hasNext()
* lastRet在两种情况下回变成-1，一个是删除完成后，一个是初始化的时候，两种情况也可以概括为一种情况，在调用remove之前没有执行next。所以说，连续两次remove()也会抛出异常。

#### 常见难点
1. 如何判断当前迭代器的位置，及如何移动？   
java的迭代器和C++中的指针类型的迭代器有很大的不同。主要区别在于两大点。 
一是java的迭代器是无法将随机访问的，也就是说不可以根据输入的数字来跳转到指定的位置，迭代器到达任何一个位置都需要经过next或者可能存在的previous方法实现，只能一个一个的移动。 
二是迭代器并不是指向一个元素的，而是指向元素之间的。迭代器初始化之后再0号元素之前，迭代到尾之后是在最后一个元素之后，期间任何一点都是指向两个元素之间的位置。  
因此在每次调用迭代器之前通常都需要进行查询即使用hasNext方法确定是否已经迭代到尾，如果迭代到尾就返回false。如果已经迭代到尾还强行的运行next则会抛出异常。

2. 如何对迭代的元素进行删除，及删除后的影响？   
由于java的迭代器没有办法进行随机访问，因此如果需要删除元素也只能删除刚刚跳过的元素。这样也导致每次remove之前必定有一个next。如果连续进行两次remove则会抛出异常。因为并不知道删除的元素是哪一个。

3. 如何防止多个迭代器之间的相互影响？   
在使用迭代器的时候，如果一个迭代器正在迭代，另一个迭代器修改了元素这样可能会导致很严重的问题。java采用一个`计数器`来保证不会有两个迭代器同时修改这个对象。通常来说如果迭代器在进行访问时，另一个迭代器结构性的修改了对象，则`正在访问的迭代器会抛出异常`。但是如果是多个迭代器只进行读操作就可以。当然也可以自定义的修改成多个读迭代器和一个写迭代器。这样可以提高访问速率。  
每个需要迭代的对象（这里就是ArrayList对象）保存一个modCount。这个数字在每次进行结构性修改的时候加1。每个迭代器保存一个expectedModCount ，来记录这个迭代器对对象进行结构性修改的次数。这样每次迭代器进结构性修改的时候都将expectedModCount 和modCount进行对比，如果两种相等则说明没有其他迭代器修改了对象，可以进行。如果不相等则说明有迭代进行了修改，立刻抛出异常。